<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>tensor-0.1.0: Operations among Tensor&#39;s</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">tensor-0.1.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sec_tensor_op.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Operations among Tensor's </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The following discussion of operations is not intented to be complete, and several of the more arcane or complex functions are not detailed here. For these, see either the documentation or have a look in the include files (especially <a class="el" href="tensor_8h_source.html">tensor.h</a>). All functions, like the whole rest of the code, reside in the tensor namespace. Consequently, you either have to prepend all functions here with "tensor::", or import them or the whole tensor namespace with a using-directive.</p>
<h1><a class="anchor" id="sec_tensor_shape"></a>
Tensor shapes and ranks</h1>
<p>In some applications, the actual shape of a tensor should be modified without modifying the content. Similar to their Matlab counterparts, the <a class="el" href="group___tensors.html#ga3698f99cb1b403756424b9278060d393" title="Return a RTensor with same data and given dimensions. ">reshape()</a> function gives a tensor an arbitrary shape, and <a class="el" href="group___tensors.html#ga902efa107f759900d3310f5e0b5a90e4" title="Eliminate all singleton dimensions from a tensor, preserving the data. ">squeeze()</a> removes dimensions of size 1. To modify the dimensions of a tensor, the permute() function swaps two indices of a tensor, also modifying the content.</p>
<div class="fragment"><div class="line">CTensor a = CTensor::random(5, 4);</div>
<div class="line">CTensor b = <a class="code" href="group___tensors.html#ga3698f99cb1b403756424b9278060d393">reshape</a>(a, 1, 2, 2, 5); <span class="comment">// b is a 1x2x2x5 tensor with the same data as a</span></div>
<div class="line">CTensor c = <a class="code" href="group___tensors.html#ga902efa107f759900d3310f5e0b5a90e4">squeeze</a>(b);             <span class="comment">// c is now a 2x2x5 tensor</span></div>
<div class="line">CTensor d = permute(a, 0, -1);      <span class="comment">// swaps first and last index, d(i,j) == a(j,i)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_tensor_unop"></a>
Unary Tensor operations</h1>
<p>The library contains a limited number of unary elementwise operators for tensors. These include negation (- A) and special functions (cos(), exp(), sqrt() etc). For complex tensors, common operations are also supported (abs(), <a class="el" href="group___tensors.html#ga795cb3a6f649a828919847de88583ab7" title="Complex conjugate of a real tensor. ">conj()</a>, real(), imag()).</p>
<h1><a class="anchor" id="sec_tensor_binop"></a>
Binary Tensor operations</h1>
<p>The library supports various operations between tensors. Elementwise addition, subtraction, multiplication and division are implemented. Furthermore, it is possible to compare tensors via all standard operators (==, &lt; etc.). The result of such comparisons is a vector of booleans that holds the result for each element. If two tensors should be compared for exact equality, you can also use the functions all_equal() and some_unequal().</p>
<h1><a class="anchor" id="sec_tensor_fold"></a>
Contractions, scaling and tracing</h1>
<p>Tensor contractions constitute a generalization of matrix multiplication for tensor with more than two indices and come in two flavors.</p>
<p>The first flavor is "exterior" contraction, in which the indices of the tensor are simply joined together. This is done with the function fold(), which takes four arguments, as in fold(A, nA, B, nB). The two arguments A and B are two tensors, while nA and nB represent the indices that are contracted.</p>
<p>For instance, assuming that A has two and B three indices, the code <code>C=fold(A,0,B,1)</code> contracts the second and first index of tensors A and B, respectively, as given by the formula </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{a_1 b_0 b_2} = \sum_j A_{j a_1} B_{b_0 j b_2} \]" src="form_0.png"/>
</p>
<p> Note that the indices of B are simply added to those of A, in that precise order.</p>
<p>The other flavor is "internal" contraction, in which indices are replaced. Going back to the previous example, <code>C=foldin(A,0,B,1)</code> contracts tensors A and B according to the formula </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{b_0 a_1 b_2} = \sum_j A_{j a_1} B_{b_0 j b_2} \]" src="form_1.png"/>
</p>
<p> Now the uncontracted indices of A appear in the place of the contracted index of B. This routine is very useful for applying transformations on certain indices of a tensor. Typically, A is a matrix describing an operator that only modifies the index / degree of freedom j.</p>
<p>Various derivates of these functions exist. The routine foldc() uses the complex conjugate of A for the contraction. The routines fold_into() and foldin_into() allow you to specify the target tensor as the first element. This is useful to avoid expensive memory allocation if you already have a fitting tensor for C lying around.</p>
<p>Another operation that can be done with tensors is scaling. For a tensor A with, say, three indices and a one-dimensional tensor (vector) V, the expression <code>C=scale(A,2,V)</code> scales A according to the formula </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{a_0 a_1 a_2} = A_{a_0 a_1 a_2} V_{a_2} \]" src="form_2.png"/>
</p>
<p> A variant scale_inplace exists that stores the result of the scaling directly in A.</p>
<p>Finally, you can trace out indices. For a tensor A with three indices, the function <code>C=trace(A,0,2)</code> calculates C as </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{k} = \sum_i A_{i k i} \]" src="form_3.png"/>
</p>
<h1><a class="anchor" id="sec_tensor_reduction"></a>
Tensor reductions</h1>
<p>Various functions allow the reduction of one or two tensors to a single value. The functions sum() and mean() return the expected sum or mean value of all tensor entries.</p>
<p>The scalar product <code>scprod(A,B)</code> of two tensors A, B (interpreted as one-dimensional vectors of numbers) is given by </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_i A_i B_i^\ast \]" src="form_4.png"/>
</p>
<p>Two norms are provided: A maximum norm <code>norm0(A)</code> returns the entry of A with the largest absolute value. The usual L2-norm, <code>norm2(A)</code> is equivalent to the expression <code>sqrt(scprod(A,A))</code>.</p>
<h1><a class="anchor" id="sec_tensor_matrix"></a>
Matrix operations</h1>
<p>For matrices, i.e., tensors of rank two, there are a few specialized functions. The multiplication of two matrices A, B is a special case of tensor contractions, and is implemented by the function mmult(A,B).</p>
<p>You can take a vector V, and build from this a matrix by interpreting the values of V as the diagonal of a matrix. The code <code>A=diag</code>(V,-1,5,6) returns a 5x6 matrix that is zero except for the first side diagonal, which contains the elements of V, i.e., <img class="formulaInl" alt="$ A_{j, j-1} = V_{j} $" src="form_5.png"/>).</p>
<p>For the special case of matrices, there are also the functions transpose() and adjoint(). Furthermore, a convenience trace() function is supplied that takes only the matrix as parameter and returns the matrix trace.</p>
<h1><a class="anchor" id="sec_tensor_further"></a>
Further operations</h1>
<p>There are also a couple of further functions for complex manipulations.</p>
<p>The namespace linalg (header <a class="el" href="linalg_8h_source.html">linalg.h</a>) contains various linear algebra decomposition routines for matrices. There are also routines for Fast Fourier Transformations of tensors along arbitrary indices (header <a class="el" href="fftw_8h_source.html">fftw.h</a>). These functionalities may only be available with special configuration options, though. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Tensor Library Documentation</a></li>
    <li class="footer">Generated on Tue Jun 10 2014 10:24:16 for tensor-0.1.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
