<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>tensor-0.1.0: Linear algebra</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">tensor-0.1.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___linalg.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Linear algebra</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinalg_1_1_c_arpack.html">linalg::CArpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finder of a few eigenvalues of eigenvectors via Arnoldi method.  <a href="classlinalg_1_1_c_arpack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinalg_1_1_r_arpack.html">linalg::RArpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finder of a few eigenvalues of eigenvectors via Arnoldi method.  <a href="classlinalg_1_1_r_arpack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0e4ec784f4458bbd15ae11915f121973"><td class="memItemLeft" align="right" valign="top">const CTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga0e4ec784f4458bbd15ae11915f121973">linalg::eig</a> (const RTensor &amp;A, CTensor *R=0, CTensor *L=0)</td></tr>
<tr class="memdesc:ga0e4ec784f4458bbd15ae11915f121973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a real matrix.  <a href="#ga0e4ec784f4458bbd15ae11915f121973">More...</a><br/></td></tr>
<tr class="separator:ga0e4ec784f4458bbd15ae11915f121973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ad18fad9dfd09e61f0d187fc404738"><td class="memItemLeft" align="right" valign="top">const CTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga96ad18fad9dfd09e61f0d187fc404738">linalg::eig</a> (const CTensor &amp;A, CTensor *R=0, CTensor *L=0)</td></tr>
<tr class="memdesc:ga96ad18fad9dfd09e61f0d187fc404738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a complex matrix.  <a href="#ga96ad18fad9dfd09e61f0d187fc404738">More...</a><br/></td></tr>
<tr class="separator:ga96ad18fad9dfd09e61f0d187fc404738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3da65f0bb9843b9b138d1d99205ba71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac3da65f0bb9843b9b138d1d99205ba71"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#gac3da65f0bb9843b9b138d1d99205ba71">linalg::eig_power_left</a> (const RTensor &amp;O, RTensor *vector, size_t iter, double tol)</td></tr>
<tr class="memdesc:gac3da65f0bb9843b9b138d1d99205ba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left eigenvalue and eigenvector with the largest absolute value, computed using the power method. <br/></td></tr>
<tr class="separator:gac3da65f0bb9843b9b138d1d99205ba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256454b9b73560ab45c1130d705d4d13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga256454b9b73560ab45c1130d705d4d13"></a>
tensor::cdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga256454b9b73560ab45c1130d705d4d13">linalg::eig_power_left</a> (const CTensor &amp;O, CTensor *vector, size_t iter, double tol)</td></tr>
<tr class="memdesc:ga256454b9b73560ab45c1130d705d4d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left eigenvalue and eigenvector with the largest absolute value, computed using the power method. <br/></td></tr>
<tr class="separator:ga256454b9b73560ab45c1130d705d4d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6c3207c148a68ca04839c039692c99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f6c3207c148a68ca04839c039692c99"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga2f6c3207c148a68ca04839c039692c99">linalg::eig_power_right</a> (const RTensor &amp;O, RTensor *vector, size_t iter, double tol)</td></tr>
<tr class="memdesc:ga2f6c3207c148a68ca04839c039692c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right eigenvalue and eigenvector with the largest absolute value, computed using the power method. <br/></td></tr>
<tr class="separator:ga2f6c3207c148a68ca04839c039692c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga030b5c6d9de9c1c8fa8e55c6b6b034df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga030b5c6d9de9c1c8fa8e55c6b6b034df"></a>
tensor::cdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga030b5c6d9de9c1c8fa8e55c6b6b034df">linalg::eig_power_right</a> (const CTensor &amp;O, CTensor *vector, size_t iter, double tol)</td></tr>
<tr class="memdesc:ga030b5c6d9de9c1c8fa8e55c6b6b034df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right eigenvalue and eigenvector with the largest absolute value, computed using the power method. <br/></td></tr>
<tr class="separator:ga030b5c6d9de9c1c8fa8e55c6b6b034df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb807c22117d2b49e910f5f809aa834a"><td class="memItemLeft" align="right" valign="top">RTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#gadb807c22117d2b49e910f5f809aa834a">linalg::eig_sym</a> (const RTensor &amp;A, RTensor *V)</td></tr>
<tr class="memdesc:gadb807c22117d2b49e910f5f809aa834a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a real matrix.  <a href="#gadb807c22117d2b49e910f5f809aa834a">More...</a><br/></td></tr>
<tr class="separator:gadb807c22117d2b49e910f5f809aa834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5deee47a69923c994dd8811b43c354f"><td class="memItemLeft" align="right" valign="top">RTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#gaf5deee47a69923c994dd8811b43c354f">linalg::eig_sym</a> (const CTensor &amp;A, CTensor *V)</td></tr>
<tr class="memdesc:gaf5deee47a69923c994dd8811b43c354f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a complex matrix.  <a href="#gaf5deee47a69923c994dd8811b43c354f">More...</a><br/></td></tr>
<tr class="separator:gaf5deee47a69923c994dd8811b43c354f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff0bc688cb6bc952c416ee8728dbc2c"><td class="memItemLeft" align="right" valign="top">const RTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#gacff0bc688cb6bc952c416ee8728dbc2c">linalg::expm</a> (const RTensor &amp;Aunorm, unsigned int order)</td></tr>
<tr class="memdesc:gacff0bc688cb6bc952c416ee8728dbc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a real matrix.  <a href="#gacff0bc688cb6bc952c416ee8728dbc2c">More...</a><br/></td></tr>
<tr class="separator:gacff0bc688cb6bc952c416ee8728dbc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7955e871edda250ca5c660589fd1f8c4"><td class="memItemLeft" align="right" valign="top">const CTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga7955e871edda250ca5c660589fd1f8c4">linalg::expm</a> (const CTensor &amp;Aunorm, unsigned int order)</td></tr>
<tr class="memdesc:ga7955e871edda250ca5c660589fd1f8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the exponential of a real matrix.  <a href="#ga7955e871edda250ca5c660589fd1f8c4">More...</a><br/></td></tr>
<tr class="separator:ga7955e871edda250ca5c660589fd1f8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae130fad313ce14f867f3d15adc9ff7e8"><td class="memItemLeft" align="right" valign="top">const RTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#gae130fad313ce14f867f3d15adc9ff7e8">linalg::solve</a> (const RTensor &amp;A, const RTensor &amp;B)</td></tr>
<tr class="memdesc:gae130fad313ce14f867f3d15adc9ff7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a real linear system of equations by Gauss-Seidel method.  <a href="#gae130fad313ce14f867f3d15adc9ff7e8">More...</a><br/></td></tr>
<tr class="separator:gae130fad313ce14f867f3d15adc9ff7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6adfaf34560b4ba40807450899fe9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f6adfaf34560b4ba40807450899fe9a"></a>
const CTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga3f6adfaf34560b4ba40807450899fe9a">linalg::solve</a> (const CTensor &amp;A, const CTensor &amp;B)</td></tr>
<tr class="memdesc:ga3f6adfaf34560b4ba40807450899fe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a complex linear system of equations by Gauss-Seidel method. <br/></td></tr>
<tr class="separator:ga3f6adfaf34560b4ba40807450899fe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cc879190b66818cc41ce40033aa588"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtensor_1_1_r_tensor.html">RTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga35cc879190b66818cc41ce40033aa588">linalg::solve_with_svd</a> (const <a class="el" href="structtensor_1_1_r_tensor.html">RTensor</a> &amp;A, const <a class="el" href="structtensor_1_1_r_tensor.html">RTensor</a> &amp;B, double tol)</td></tr>
<tr class="memdesc:ga35cc879190b66818cc41ce40033aa588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of a linear system of equations using Penrose's pseudoinvese.  <a href="#ga35cc879190b66818cc41ce40033aa588">More...</a><br/></td></tr>
<tr class="separator:ga35cc879190b66818cc41ce40033aa588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0946d1ec56c7b31e2d6a63692d12394c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtensor_1_1_c_tensor.html">CTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga0946d1ec56c7b31e2d6a63692d12394c">linalg::solve_with_svd</a> (const <a class="el" href="structtensor_1_1_c_tensor.html">CTensor</a> &amp;A, const <a class="el" href="structtensor_1_1_c_tensor.html">CTensor</a> &amp;B, double tol)</td></tr>
<tr class="memdesc:ga0946d1ec56c7b31e2d6a63692d12394c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution of a linear system of equations using Penrose's pseudoinvese.  <a href="#ga0946d1ec56c7b31e2d6a63692d12394c">More...</a><br/></td></tr>
<tr class="separator:ga0946d1ec56c7b31e2d6a63692d12394c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6"><td class="memItemLeft" align="right" valign="top">RTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6">linalg::svd</a> (RTensor A, RTensor *U, RTensor *VT, bool economic)</td></tr>
<tr class="memdesc:gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition of a real matrix.  <a href="#gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6">More...</a><br/></td></tr>
<tr class="separator:gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef40d346288788ded74d837ef4b8db2"><td class="memItemLeft" align="right" valign="top">RTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___linalg.html#ga8ef40d346288788ded74d837ef4b8db2">linalg::svd</a> (CTensor A, CTensor *U, CTensor *VT, bool economic)</td></tr>
<tr class="memdesc:ga8ef40d346288788ded74d837ef4b8db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition of a complex matrix.  <a href="#ga8ef40d346288788ded74d837ef4b8db2">More...</a><br/></td></tr>
<tr class="separator:ga8ef40d346288788ded74d837ef4b8db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0e4ec784f4458bbd15ae11915f121973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CTensor linalg::eig </td>
          <td>(</td>
          <td class="paramtype">const RTensor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTensor *&#160;</td>
          <td class="paramname"><em>R</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTensor *&#160;</td>
          <td class="paramname"><em>L</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvalue decomposition of a real matrix. </p>
<p>Given a square matrix A, we find a diagonal matrix D and a set of vectors R or L such that A R = R D or L A = D L</p>
<p>The eigenvalue decomposition is computed using the DGEEV routine from the LAPACK library. By default, only the diagonal elements of S are computed. However, also the U and V matrices can be computed if pointers to the associated variables are supplied. </p>

<p>Definition at line <a class="el" href="eig__d_8cc_source.html#l00045">45</a> of file <a class="el" href="eig__d_8cc_source.html">eig_d.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga96ad18fad9dfd09e61f0d187fc404738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CTensor linalg::eig </td>
          <td>(</td>
          <td class="paramtype">const CTensor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTensor *&#160;</td>
          <td class="paramname"><em>R</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTensor *&#160;</td>
          <td class="paramname"><em>L</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvalue decomposition of a complex matrix. </p>
<p>Given a square matrix A, we find a diagonal matrix D and a set of vectors R or L such that A R = R D or L A = D L</p>
<p>The eigenvalue decomposition is computed using the ZGEEV routine from the LAPACK library. By default, only the diagonal elements of S are computed. However, also the U and V matrices can be computed if pointers to the associated variables are supplied. </p>

<p>Definition at line <a class="el" href="eig__z_8cc_source.html#l00047">47</a> of file <a class="el" href="eig__z_8cc_source.html">eig_z.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gadb807c22117d2b49e910f5f809aa834a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTensor linalg::eig_sym </td>
          <td>(</td>
          <td class="paramtype">const RTensor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTensor *&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvalue decomposition of a real matrix. </p>
<p>Given a square matrix A, we find a diagonal matrix D and a set of vectors R or L such that A V = V D and transpose(V) A = D transpose(V)</p>
<p>The matrix A must be symmetric (transpose(A)==A).</p>
<p>By default, only the diagonal elements of D are computed. However, also the matrix V can be computed if a pointer to the associated variable is supplied. </p>

<p>Definition at line <a class="el" href="eig__sym__d_8cc_source.html#l00044">44</a> of file <a class="el" href="eig__sym__d_8cc_source.html">eig_sym_d.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5deee47a69923c994dd8811b43c354f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTensor linalg::eig_sym </td>
          <td>(</td>
          <td class="paramtype">const CTensor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTensor *&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvalue decomposition of a complex matrix. </p>
<p>Given a square matrix A, we find a diagonal matrix D and a set of vectors R or L such that A V = V D and adjoint(V) A = D adjoint(V)</p>
<p>The matrix A must be Hermitian (adjoint(A)==A).</p>
<p>By default, only the diagonal elements of D are computed. However, also the matrix V can be computed if a pointer to the associated variable is supplied. </p>

<p>Definition at line <a class="el" href="eig__sym__z_8cc_source.html#l00044">44</a> of file <a class="el" href="eig__sym__z_8cc_source.html">eig_sym_z.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gacff0bc688cb6bc952c416ee8728dbc2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const RTensor linalg::expm </td>
          <td>(</td>
          <td class="paramtype">const RTensor &amp;&#160;</td>
          <td class="paramname"><em>Aunorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the exponential of a real matrix. </p>
<p>This function computes the exponential of a matrix using a Pade approximation of any given order.</p>
<p>This is potentially more accurate than using the eigenvalues of the matrix or a Taylor expansion of the exponential, and much faster, since it only involves products of matrices and solving one system of equations.</p>
<p>The current algorithm has been adapted from Scientific Python, the version written by Travis Oliphant (2002). It is slightly more accurate than the same Matlab version when computed with the default order of 7. </p>

<p>Definition at line <a class="el" href="expm__d_8cc_source.html#l00042">42</a> of file <a class="el" href="expm__d_8cc_source.html">expm_d.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga7955e871edda250ca5c660589fd1f8c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CTensor linalg::expm </td>
          <td>(</td>
          <td class="paramtype">const CTensor &amp;&#160;</td>
          <td class="paramname"><em>Aunorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the exponential of a real matrix. </p>
<p>This function computes the exponential of a matrix using a Pade approximation of any given order.</p>
<p>This is potentially more accurate than using the eigenvalues of the matrix or a Taylor expansion of the exponential, and much faster, since it only involves products of matrices and solving one system of equations.</p>
<p>The current algorithm has been adapted from Scientific Python, the version written by Travis Oliphant (2002). It is slightly more accurate than the same Matlab version when computed with the default order of 7. </p>

<p>Definition at line <a class="el" href="expm__z_8cc_source.html#l00040">40</a> of file <a class="el" href="expm__z_8cc_source.html">expm_z.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gae130fad313ce14f867f3d15adc9ff7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const RTensor linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const RTensor &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RTensor &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a real linear system of equations by Gauss-Seidel method. </p>
<p>Given a matrix A, and a right hand matrix B, we find the matrix X that satisfies A X = B using the LU factorization.</p>
<p>The solution is computed using the DGESV/ZGESV routines from LAPACK. </p>

<p>Definition at line <a class="el" href="solve__d_8cc_source.html#l00039">39</a> of file <a class="el" href="solve__d_8cc_source.html">solve_d.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga35cc879190b66818cc41ce40033aa588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtensor_1_1_r_tensor.html">RTensor</a> linalg::solve_with_svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensor_1_1_r_tensor.html">RTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtensor_1_1_r_tensor.html">RTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution of a linear system of equations using Penrose's pseudoinvese. </p>
<p>This function solves the system of equations A * X = B using the SVD of the matrix A = U * S * VT, through the formula X = V * (S^-1) * UT * B. When computing (S^-1), singular values below the tolerance are discarded. </p>

<p>Definition at line <a class="el" href="solve__with__svd__d_8cc_source.html#l00037">37</a> of file <a class="el" href="solve__with__svd__d_8cc_source.html">solve_with_svd_d.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga0946d1ec56c7b31e2d6a63692d12394c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtensor_1_1_c_tensor.html">CTensor</a> linalg::solve_with_svd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensor_1_1_c_tensor.html">CTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtensor_1_1_c_tensor.html">CTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution of a linear system of equations using Penrose's pseudoinvese. </p>
<p>This function solves the system of equations A * X = B using the SVD of the matrix A = U * S * VT, through the formula X = V * (S^-1) * UT * B. When computing (S^-1), singular values below the tolerance are discarded. </p>

<p>Definition at line <a class="el" href="solve__with__svd__z_8cc_source.html#l00037">37</a> of file <a class="el" href="solve__with__svd__z_8cc_source.html">solve_with_svd_z.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTensor linalg::svd </td>
          <td>(</td>
          <td class="paramtype">RTensor&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTensor *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTensor *&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>economic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singular value decomposition of a real matrix. </p>
<p>The singular value decomposition of a matrix A, consists in finding two unitary matrices U and V, and diagonal one S with nonnegative elements, such that <img class="formulaInl" alt="$A = U S V$" src="form_8.png"/>. The <a class="el" href="group___linalg.html#gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6" title="Singular value decomposition of a real matrix. ">svd()</a> routine computes the diagonal elements of the matrix S and puts them in a 1D tensor, which is the output of the routine. Optionally, the matrices U and V are also computed, and stored in the variables pointed to by U and VT.</p>
<p>Unless otherwise specified, if the matrix A has <code>MxN</code> elements, then U is <code>MxM</code>, V is <code>NxN</code> and the vector S will have <code>min(M,N)</code> elements. However if flag <code>economic</code> is different from zero, then we get smaller matrices, U being <code>MxR</code>, V being <code>RxN</code> and S will have <code>R=min(M,N)</code> elements. </p>

<p>Definition at line <a class="el" href="svd__d_8cc_source.html#l00050">50</a> of file <a class="el" href="svd__d_8cc_source.html">svd_d.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ef40d346288788ded74d837ef4b8db2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTensor linalg::svd </td>
          <td>(</td>
          <td class="paramtype">CTensor&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTensor *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CTensor *&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>economic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singular value decomposition of a complex matrix. </p>
<p>The singular value decomposition of a matrix A, consists in finding two unitary matrices U and V, and diagonal one S with nonnegative elements, such that <img class="formulaInl" alt="$A = U S V$" src="form_8.png"/>. The <a class="el" href="group___linalg.html#gaefcb2bb9e2edf79c8ed9c7a5e5ba8cf6" title="Singular value decomposition of a real matrix. ">svd()</a> routine computes the diagonal elements of the matrix S and puts them in a 1D tensor, which is the output of the routine. Optionally, the matrices U and V are also computed, and stored in the variables pointed to by U and VT.</p>
<p>Unless otherwise specified, if the matrix A has <code>MxN</code> elements, then U is <code>MxM</code>, V is <code>NxN</code> and the vector S will have <code>min(M,N)</code> elements. However if flag <code>economic</code> is different from zero, then we get smaller matrices, U being <code>MxR</code>, V being <code>RxN</code> and S will have <code>R=min(M,N)</code> elements. </p>

<p>Definition at line <a class="el" href="svd__z_8cc_source.html#l00045">45</a> of file <a class="el" href="svd__z_8cc_source.html">svd_z.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jun 10 2014 10:24:16 for tensor-0.1.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
