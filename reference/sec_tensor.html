<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>tensor-0.1.0: The Tensor class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">tensor-0.1.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sec_tensor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Tensor class </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_tensor_intro"></a>
Basics of the Tensor class</h1>
<p>A Tensor is a multidimensional array of numbers; in practice, they are constrained to real or complex double precision numbers. Their behavior is similar to Matlab's arrays in that they can store only numbers, be accessed with one or more indices using the () or [] syntaxes, reshaped, sliced, and all that with an automated memory management.</p>
<p>Internally, a Tensor consists of two data items: A Vector containing the dimensions, and a Vector containing the raw data. The Tensor class (or rather the underlying Vector class) makes excessive use of copy-on-write. Therefore, modifying the dimensions of a tensor is usually a cheap operation, while modifying the data may be expensive.</p>
<p>To simplify the interfacing to BLAS/LAPACK libraries, the data is aligned in row-major ordering (as in Fortran, and in contrast to C++).</p>
<p>For all functions that require indices of the tensor (e.g., accessing elements, creating a tensor), explicit functions for up to six-dimensional tensors are provided. For cases with more than six dimensions, or if the dimensions should not be required, there is an additional function that works with an Indices class. The setup is explained further below.</p>
<h1><a class="anchor" id="sec_tensor_create"></a>
Creating a Tensor</h1>
<p>To create a new tensor with uninitialized content, you can use the standard constructor</p>
<div class="fragment"><div class="line">CTensor ca = CTensor(2, 3);    <span class="comment">// creates a 2x3 matrix of complex doubles</span></div>
<div class="line">RTensor ra = RTensor(5, 4, 3); <span class="comment">// creates a 5x4x3 tensor of doubles</span></div>
</div><!-- fragment --><p>For convenience, there exist a couple of other static functions that produce standard tensors</p>
<div class="fragment"><div class="line">RTensor a = RTensor::random(3, 2);  <span class="comment">// fill the tensor with random content</span></div>
<div class="line">CTensor b = CTensor::eye(5, 5);     <span class="comment">// unity matrix; only works for up to 2 dimensions</span></div>
<div class="line">CTensor c = CTensor::zeros(3, 4, 5);<span class="comment">// fills the tensor with zeros</span></div>
<div class="line">RTensor d = RTensor::ones(4, 3);    <span class="comment">// fills the tensor with ones; explicit functions only for up to 2 dims</span></div>
</div><!-- fragment --><p>Tensors can also be created statically inside the code; this is explained further below. Finally, there is also some basic functionality to write Tensors to files and read them afterwards; for this, see the sdf namespace.</p>
<h1><a class="anchor" id="sec_tensor_single"></a>
Accessing single elements of a tensor</h1>
<p>There are two different access mechanisms if you want to retrieve a single entry in the Tensor. You can view the data as a linear sequence of numbers and read a given index, or you can use the dimension information of the tensor. For each access mechanism, a reading and a writing function is provided.</p>
<p>To access the data sequentially, you can use the square brackets, and the function at_seq().</p>
<div class="fragment"><div class="line">RTensor t = RTensor::eye(2,2);  <span class="comment">// The final tensor is ( 1 0 )</span></div>
<div class="line">t.at(1,0) = 2;                  <span class="comment">//                     ( 2 1 )</span></div>
<div class="line">t[0];               <span class="comment">// returns 1.0</span></div>
<div class="line">t[1];               <span class="comment">// returns 2.0</span></div>
<div class="line">t.at_seq(2) = 5.1;  <span class="comment">// sets the upper right number</span></div>
</div><!-- fragment --><p>To access the data using the Tensor's dimensions, you can use brackets or the function at(). Note that indices can be positive or negative, where the latter means "count from the end". For example, -1 means the last element along a dimension. This convention is by the way also used whenever a dimension is requested, a -1 would refer to the last dimension.</p>
<div class="fragment"><div class="line">RTensor t = RTensor::eye(2,2);</div>
<div class="line">t(0,0);                        <span class="comment">// first row, first column</span></div>
<div class="line">t(1,0);                        <span class="comment">// second row, first column</span></div>
<div class="line">t(-1,1);                       <span class="comment">// last (i.e., second) row, second column</span></div>
<div class="line">t.at(1,0) = t.at(0,1) = 1;     <span class="comment">// now all elements of t are 1.</span></div>
</div><!-- fragment --><p>The various write functions return a reference to the corresponding element. To disallow these functions, you can always declare a tensor as constant.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> RTensor t = RTensor::random(5, 4);</div>
<div class="line">t[0];                                    <span class="comment">// OK</span></div>
<div class="line">t(4,0);                                  <span class="comment">// OK</span></div>
<div class="line">t.at_seq(3) = 1.2;                       <span class="comment">// compilation error: modifies tensor</span></div>
<div class="line">t.at(2,2)   = 5.0;                       <span class="comment">// also fails on compilation</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_tensor_slices"></a>
Tensor slicing</h1>
<p>To access more than one element of a tensor, you can use the range() function together with ordinary brackets to get slices. This works similar to Matlab's slice notation. The range() function can take a number of integer arguments, or an Indices vector (see the section on using Indices) to access various items. As with single entries, negative values are accepted, and count from the end of the dimension. Note that all parameters either have to be numbers, thus retrieving a single item, or slices.</p>
<div class="fragment"><div class="line">CTensor t = CTensor::random(5,5);</div>
<div class="line"></div>
<div class="line">CTensor full  = t(range(), range());          <span class="comment">// no argument  -&gt; take all Indices</span></div>
<div class="line">CTensor row   = t(range(2), range());         <span class="comment">// one argument -&gt; take only given index</span></div>
<div class="line">CTensor full2 = t(range(1,-1), range());      <span class="comment">// two arguments-&gt; start and stop</span></div>
<div class="line">CTensor evenRows = t(range(1,-1,2), range()); <span class="comment">// three args   -&gt; start,stop,stride</span></div>
<div class="line">CTensor oddRows = t(range(igen&lt;&lt;1&lt;&lt;3), range());<span class="comment">// Indices as argument</span></div>
</div><!-- fragment --><p>To assign data, you can use again the at() function. You can assign three things: Either a single value or another tensor or slice with the same dimensions.</p>
<div class="fragment"><div class="line">CTensor dest = CTensor::zeros(5,3);</div>
<div class="line">CTensor col  = CTensor::ones(5,1);</div>
<div class="line"></div>
<div class="line">dest.at(range(), range(0)) = 5.0;     <span class="comment">// first column gets complex value (5.0, 0)</span></div>
<div class="line">dest.at(range(), range(1)) = col;     <span class="comment">// second column gets content of col</span></div>
<div class="line">dest.at(range(), range(2)) = dest(range(), range(1));  <span class="comment">// copy to third column</span></div>
</div><!-- fragment --><p>Note that the return value is in both cases an internal data structure that is either transparently cast to a tensor, or accepts the assigned data. If you keep this data without casting to another Tensor, you will effectively create a loophole in the copy-on-write mechanism. For this reason, you must never use the C++-11 auto feature, unless you know exactly what you are doing (you do not).</p>
<div class="fragment"><div class="line">CTensor t = CTensor::random(5,5);</div>
<div class="line"><span class="keyword">auto</span> view = t(range(), range(0,1));    <span class="comment">// creates an unsafe object that bypasses copy-on-write</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_tensor_shape"></a>
Tensor shapes and ranks</h1>
<p>To query the dimensions, the tensor class offers a couple of functions:</p>
<div class="fragment"><div class="line">CTensor t = CTensor::zeros(5, 4, 3);</div>
<div class="line"></div>
<div class="line">index rank = t.rank();           <span class="comment">// number of dimensions: 3</span></div>
<div class="line">index size = t.size();           <span class="comment">// total size: 5*4*3 = 60</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> d1 = t::dimension(0);        <span class="comment">// number of entries in first dimension: 5</span></div>
<div class="line"><span class="keywordtype">int</span> d2 = t::dimension(1);        <span class="comment">// along second dimension: 4</span></div>
<div class="line"><span class="keywordtype">int</span> d3 = t::dimension(2);        <span class="comment">// along third dimension: 3</span></div>
<div class="line"></div>
<div class="line">t::get_dimensions(&amp;d1, &amp;d2, &amp;d3);<span class="comment">// same: returns the three dimensions</span></div>
<div class="line"></div>
<div class="line">Indices dims = t::dimensions();  <span class="comment">// Returns an index vector with the dimensions</span></div>
<div class="line">d1 = dims[0];                    <span class="comment">// etc.</span></div>
</div><!-- fragment --><p>The function dimensions() is handy to produce an Indices vector that can later be used for convenient manipulations if you want to abstract away the exact rank of the tensor. For two-dimensional tensors, and only for those, the class also offers the rows() and columns() functions, which are equivalent to dimension(0) and dimension(1);</p>
<p>If you want to modify the shape of a tensor, you can use the <a class="el" href="group___tensors.html#ga3698f99cb1b403756424b9278060d393" title="Return a RTensor with same data and given dimensions. ">reshape()</a> function</p>
<div class="fragment"><div class="line">CTensor t = CTensor::random(5,4);</div>
<div class="line">CTensor t2 = <a class="code" href="group___tensors.html#ga3698f99cb1b403756424b9278060d393">reshape</a>(t, 4, 5);</div>
<div class="line"></div>
<div class="line">t.dimension(0) == t2.dimension(1);  <span class="comment">// both comparisons evaluate to true</span></div>
<div class="line">t.dimension(1) == t2.dimension(0);</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_tensor_indices"></a>
Using Indices vectors</h1>
<p>Typically, the library provides functions that are overloaded for up to six dimensional tensors. Sometimes, however, you might have larger objects, or you want to write a function or routine that can deal with tensors of varying dimensions. In this case, you have to work with Indices.</p>
<p>At its heart, an Indices object is just a fixed-sized vector of integer values. It uses the same copy-on-write mechanism as the Tensor class (actually, the data of tensors is implemented with the same vector class). You can use again the square brackets and the at() function with an index parameter for read / write access to the content.</p>
<div class="fragment"><div class="line">CTensor t = CTensor::random(4, 5, 6);</div>
<div class="line">Indices dims = t.dimensions();         <span class="comment">// dims and t.dimensions() share the data</span></div>
<div class="line"></div>
<div class="line">dims.at(0) = dims[2];                  <span class="comment">// copy on write: now dims has its own copy</span></div>
<div class="line">dims.at(2) = 4;</div>
<div class="line"></div>
<div class="line">CTensor t2 = <a class="code" href="group___tensors.html#ga3698f99cb1b403756424b9278060d393">reshape</a>(t, dims);</div>
</div><!-- fragment --><p>There are various ways to construct an Indices object. Either you get it from somewhere else (like Tensor::dimensions()), or you create it by claiming some memory or static initialization.</p>
<div class="fragment"><div class="line">Indices i1 = Indices(5);              <span class="comment">// allocate 5 entries for further use</span></div>
<div class="line">Indices i2 = igen &lt;&lt; 2 &lt;&lt; 2 &lt;&lt; 4      <span class="comment">// creates an Indices object with entries (2,2,4); see next section</span></div>
<div class="line">Indices i3 = Indices::range(1, 5, 2)  <span class="comment">// start,stop,stride as parameters; i3 = (1, 3, 5)</span></div>
<div class="line">Indices i4 = i2 &lt;&lt; i3;                <span class="comment">// concatenation; i4 = (2, 2, 4, 1, 3, 5)</span></div>
</div><!-- fragment --><p>The functions all_equal() and some_unequal() can be used to compare Indices. Furthermore, all comparison operators (==, &lt;= etc.) are overloaded, and will return a vector of booleans that gives the elementwise result of the comparison.</p>
<div class="fragment"><div class="line">Indices i1 = igen &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3;</div>
<div class="line">Indices i2 = igen &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 5;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> eq = all_equal(i1, i2);      <span class="comment">// evaluates to false</span></div>
<div class="line">Boolean comp = (i1 == i2)         <span class="comment">// comp = (true, true, false)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_tensor_static"></a>
Statically creating tensors</h1>
<p>It is possible to create a tensor or vector using compile-time expressions. The syntax always follows the same pattern: first the generator, then the content separated by the operator &lt;&lt;:</p>
<div class="fragment"><div class="line">RTensor t1 = rgen &lt;&lt; 1.0 &lt;&lt; 2.0 &lt;&lt; 3.0;   <span class="comment">// real-valued vector with elements (1,2,3)</span></div>
<div class="line">CTensor t2 = cgen &lt;&lt; cdouble(1.0, 2.0);   <span class="comment">// complex-valued vector with element (1+2i)</span></div>
<div class="line">Indices i1 = igen &lt;&lt; 1 &lt;&lt; 2;              <span class="comment">// Indices object with entries (1,2)</span></div>
<div class="line">Booleans b = bgen &lt;&lt; <span class="keyword">true</span> &lt;&lt; <span class="keyword">false</span>;       <span class="comment">// boolean vector with elements (true,false)</span></div>
</div><!-- fragment --><p>A special generator is "xgen", which will convert automatically to the type of the first object that is fed into it. Internally, these expressions are evaluated using recursive templates; consequently they are evaluated at compile time and will slow down compilation if used excessively (e.g., if you feed 1000 elements in this way).</p>
<p>Note that the direct use of the generators always results in one-dimensional tensors of appropriate size. If you want to generate a tensor of a given size, you have to supply the dimensions as Indices vector. Typically, you will create this vector also statically. Note that the data is as usual interpreted in row-major form.</p>
<div class="fragment"><div class="line">RTensor a(rgen &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4,   <span class="comment">// creates matrix ( 1   2 )</span></div>
<div class="line">          igen &lt;&lt; 2 &lt;&lt; 2);            <span class="comment">//                ( 3   4 )</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Tensor Library Documentation</a></li>
    <li class="footer">Generated on Tue Jun 10 2014 10:24:16 for tensor-0.1.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
